import { BLOG_TAGS } from '@/lib/blog-tags'

export const metadata = {
  title: 'Storyblok React State Management Decision Guide: When to Use Local State vs Jotai',
  description: 'A comprehensive guide to choosing the right state management approach when building Next.js applications with Storyblok CMS, covering local state, prop passing, and Jotai atoms.',
  date: '2025-07-11T12:00:00Z',
  tags: [BLOG_TAGS.STORYBLOK, BLOG_TAGS.REACT, BLOG_TAGS.JOTAI, BLOG_TAGS.STATE_MANAGEMENT, BLOG_TAGS.CMS, BLOG_TAGS.NEXTJS, BLOG_TAGS.TYPESCRIPT, BLOG_TAGS.BEST_PRACTICES],
  authors: ['Mauricio Acosta'],
  abstract: 'Learn when and how to use different state management patterns in Storyblok React applications, from local useState to Jotai atoms, with practical decision frameworks and real-world examples.',
}

When building Next.js applications with Storyblok CMS, one of the most common challenges developers face is deciding how to manage state effectively. Should you use local React state, pass props, or reach for a state management library like Jotai? The answer depends on several factors that this guide will help you navigate.

This comprehensive decision guide provides a framework for choosing the right state management approach based on your specific use case, whether you're dealing with Storyblok content, editor state, or complex application logic.

## Understanding State Categories in Storyblok Applications

Before diving into solutions, it's crucial to understand the different types of state you'll encounter when working with Storyblok:

### 1. Content State
**Definition**: Data fetched from Storyblok API (stories, components, assets)

**Characteristics**:
- Immutable from the client perspective
- Cacheable
- Requires revalidation strategies
- Delivered through props in `<StoryblokComponent />`

### 2. Editor State
**Definition**: Live preview data from Storyblok Visual Editor

**Characteristics**:
- Real-time updates via Storyblok Bridge
- Only active in preview mode
- Requires instant reactivity

### 3. Linear State (Single-Branch Function Usage)
**Definition**: State with predictable, single-path execution - used in functions that always follow the same sequence of operations.

**Usage Pattern**: Functions that use this state have one execution path - no conditional logic, no early returns, deterministic flow.

**Characteristics**:
- Simple toggles (modal open/closed, dropdown expanded/collapsed)
- Basic form field values (input text, checkbox states)
- Visual states (hover, focus, loading indicators)
- Simple animations (fade in/out, slide transitions)
- Current tab/page selections

### 4. Conditional State (Multi-Branch Function Usage)
**Definition**: State used in logic with multiple execution paths.

**Usage Pattern**: Functions that use this state contain if/else statements, switch cases, early returns, or exception handling based on state values.

**Characteristics**:
- Shopping cart calculations (discounts, tax, shipping logic)
- Form validation with multiple error conditions
- User authentication flows (login, logout, token refresh)
- Complex filtering and search logic
- Multi-step workflows with conditional steps
- Payment processing workflows

### 5. Cross-Component State
**Definition**: State that needs to be shared between multiple Storyblok components.

**Characteristics**:
- State that spans across nested `<StoryblokComponent />` instances
- Data that child components need from distant parents
- Computed values from multiple components

## The State Management Spectrum

### 1. Local React State (`useState`, `useReducer`)

**‚úÖ Use when:**
- State is only needed by ONE component and its direct children
- State is ephemeral/temporary (form inputs, toggles, loading states)
- State doesn't need to persist across component unmounts
- Linear State scenarios
- Performance is critical and you want to avoid unnecessary re-renders
- High-frequency updates (like keystroke input)

**Examples:**

```javascript
// ‚úÖ Perfect for local state
// ‚úÖ useState - single-branch function
function DisplayUserName() {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');

  // Always executes the same operations in the same order
  return `${firstName} ${lastName}`.trim();
}

// ‚úÖ useState - single-branch toggle
function ToggleModal() {
  const [isOpen, setIsOpen] = useState(false);

  // Pure computational logic - just flips the boolean
  const toggle = () => setIsOpen(!isOpen);
  return { isOpen, toggle };
}
```

### 2. Prop Passing

**‚úÖ Use when:**
- State needs to be shared between 2-3 components in a direct parent-child relationship
- The component tree is shallow (1-2 levels deep)
- You want explicit data flow that's easy to trace
- The props are stable and don't change frequently
- Passing Storyblok content data down the component tree

**Examples:**

```javascript
// ‚úÖ Good for prop passing
<StoryblokComponent blok={blok} />

<ChatMessage
  message={message}
  onEdit={handleEdit}
  isSelected={selectedId === message.id}
/>

<Button onClick={handleSubmit} disabled={!canSubmit} />
```

### 3. Jotai Atoms (Global & Page-Scoped State)

**‚úÖ Use when:**
- State needs to be accessed by multiple components across different parts of the tree
- State should persist across component unmounts/remounts
- You have complex derived state that multiple components need
- You want to avoid prop drilling through 3+ levels
- State changes should trigger updates in distant components
- You need a single source of truth for application-wide data
- Page-specific data needs to be shared between many nested components

**Examples:**

**Global Atoms (App-wide):**
```javascript
// ‚úÖ Perfect for truly global state
const selectedModelAtom = atom("gpt-4");
const cartItemsAtom = atomWithStorage('cart', []);
const userPreferencesAtom = atom({});
const sidebarOpenAtom = atom(false);
```

**Page-Scoped Atoms (Page-specific):**
```javascript
// ‚úÖ Perfect for page-level state shared by many components
// Example: Tour page with complex data needs

// atoms/tourPage.ts
export const currentTourAtom = atom(null); // Set from server props
export const selectedDateAtom = atom(null);
export const guestCountAtom = atom({ adults: 2, children: 0 });
export const selectedAddOnsAtom = atom([]);
export const bookingStepAtom = atom(1);

// Derived atoms for tour page
export const tourPriceAtom = atom((get) => {
  const tour = get(currentTourAtom);
  const guests = get(guestCountAtom);
  const addOns = get(selectedAddOnsAtom);

  if (!tour) return 0;

  const basePrice = tour.price * (guests.adults + guests.children);
  const addOnsPrice = addOns.reduce((sum, addon) => sum + addon.price, 0);
  return basePrice + addOnsPrice;
});

export const availabilityAtom = atom((get) => {
  const tour = get(currentTourAtom);
  const date = get(selectedDateAtom);
  const guests = get(guestCountAtom);

  // Complex availability logic
  return checkAvailability(tour, date, guests);
});
```

## Provider Scoping Pattern

One powerful pattern when using Jotai with Storyblok is provider scoping, which allows you to create isolated state stores for each page:

```javascript
// ‚úÖ Use Provider scoping to reset atoms for each page
// pages/tours/[slug].tsx
import { createStore, Provider } from 'jotai';

export default function TourPage({ tour }) {
  // Create a new store instance for this specific tour page
  const tourStore = createStore();

  // Directly set initial values in the store
  tourStore.set(currentTourAtom, tour);
  tourStore.set(tourCodeAtom, tour.code); // e.g., "kad89"
  tourStore.set(guestCountAtom, { adults: 2, children: 0 });
  tourStore.set(selectedDateAtom, null);

  return (
    <Provider store={tourStore}>
      {/* This will render TourPageContent and all of
          the children will have access to the state */}
      <StoryblokComponent blok={blokData}/>
    </Provider>
  );
}

function TourPageContent() {
  // No need to set tour data here - it's already in the store!
  return (
    <>
      <TourHeader />
      <TourGallery />
      <TourDatePicker />
      <TourGuestSelector />
      <TourAddOns />
      <TourPricingSummary />
      <TourBookingForm />
    </>
  );
}

// Each component can access the atoms without prop drilling
const TourPricingSummary = () => {
  const price = useAtomValue(tourPriceAtom);
  const guests = useAtomValue(guestCountAtom);
  const addOns = useAtomValue(selectedAddOnsAtom);
  const tourCode = useAtomValue(tourCodeAtom);
  const tour = useAtomValue(currentTourAtom);

  // This will show "kad89" - proving the store isolation works
  return (
    <div className="tour-pricing-summary">
      <h3>Pricing Summary for Tour {tourCode}</h3>
      <p>Tour: {tour?.name} (Code: {tourCode})</p>
      <p>Base Price: ${tour?.price}</p>
      <p>Guests: {guests.adults} adults, {guests.children} children</p>
      <p>Total: ${price}</p>
    </div>
  );
};
```

## Master Decision Framework

When deciding on your state management approach, ask these questions in order:

### 1. "How many components need this state?"
- **1 component** ‚Üí Local state
- **2-3 related components** ‚Üí Props or local state with lifting
- **3+ or distant components** ‚Üí Jotai

### 2. "Does this state survive component unmounting?"
- **Yes** ‚Üí Jotai (like cart items persisting during navigation)
- **No** ‚Üí Local state (like dropdown open state)

### 3. "Is this state derived from other state?"
- **Yes + used by multiple components** ‚Üí Jotai derived atom
- **Yes + used by one component** ‚Üí Local useMemo
- **No** ‚Üí Depends on scope

### 4. "How often does this state change?"
- **Very frequently** (every keystroke) ‚Üí Consider local state first
- **Occasionally** ‚Üí Jotai is fine
- **Rarely** ‚Üí Either works

### 5. "Is this linear state or conditional state?"
- **Linear state** (single execution path: simple toggles, basic form fields, visual states) ‚Üí Local state
- **Conditional state** (multiple execution paths: validation logic, calculations, workflows) ‚Üí Jotai
- **Many related linear states** (coordinated toggles, multi-step processes, dependent fields) ‚Üí Consider consolidating into conditional state with Jotai

## Visual Decision Tree

```
‚îå‚îÄ Is it content from Storyblok API?
‚îÇ ‚îî‚îÄ YES ‚Üí Continue ‚Üì
‚îÇ ‚îÇ ‚îú‚îÄ Using App Router?
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ YES ‚Üí Use Server Components with fetch
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ NO ‚Üí Use getStaticProps/getServerSideProps
‚îÇ ‚îÇ
‚îÇ ‚îî ‚îÄ NO ‚Üí Continue ‚Üì
‚îÇ
‚îú‚îÄ How many components need this state?
‚îÇ ‚îú‚îÄ 1 component ‚Üí Use local useState
‚îÇ ‚îú‚îÄ 2-3 related ‚Üí Use props or lift state up
‚îÇ ‚îî‚îÄ 3+ or distant ‚Üí Continue ‚Üì
‚îÇ
‚îú‚îÄ Does state need to persist across unmounts?
‚îÇ ‚îî‚îÄ YES ‚Üí Use Jotai atoms (possibly with storage)
‚îÇ ‚îî‚îÄ NO ‚Üí Continue ‚Üì
‚îÇ
‚îú‚îÄ Is this derived from multiple sources?
‚îÇ ‚îî‚îÄ YES ‚Üí Use Jotai derived atoms
‚îÇ ‚îî‚îÄ NO ‚Üí Continue ‚Üì
‚îÇ
‚îú‚îÄ Is this linear or conditional state?
‚îÇ ‚îú‚îÄ Linear state (single path) ‚Üí Use local state
‚îÇ ‚îú‚îÄ Conditional state (multiple paths) ‚Üí Use Jotai atoms
‚îÇ ‚îî‚îÄ Many related linear states ‚Üí Consider consolidating with Jotai
```

## State Categories & Recommendations

### ‚úÖ Perfect for Local State:

```javascript
// UI Interaction State
const [isHovered, setIsHovered] = useState(false);
const [showTooltip, setShowTooltip] = useState(false);
const [isDragging, setIsDragging] = useState(false);
const [showMobileMenu, setShowMobileMenu] = useState(false);

// Temporary Form State
const [tempInput, setTempInput] = useState("");
const [validationErrors, setValidationErrors] = useState({});

// Component-Specific Loading
const [isUploading, setIsUploading] = useState(false);
const [isValidating, setIsValidating] = useState(false);

// Animation States
const [animationPhase, setAnimationPhase] = useState("idle");
```

### ‚úÖ Perfect for Jotai Atoms:

```javascript
// Application State (truly global)
const selectedModelAtom = atom("gpt-4");
const userSessionAtom = atom(null);
const appConfigAtom = atom({});

// Shared Data (across entire app)
const cartItemsAtom = atomWithStorage('cart', []);
const notificationsAtom = atom([]);

// Global UI State
const sidebarOpenAtom = atom(false);
const themeAtom = atom("light");

// Page-Scoped State (complex pages with many components)
// Example: Tour page atoms
const tourDataAtom = atom(null); // Initialize from server props
const selectedDateAtom = atom(null);
const guestCountAtom = atom({ adults: 2, children: 0 });
const selectedAddOnsAtom = atom([]);

// Derived/Computed State
const tourPriceAtom = atom((get) => {
  const tour = get(tourDataAtom);
  const guests = get(guestCountAtom);
  const addOns = get(selectedAddOnsAtom);

  if (!tour) return 0;
  return calculateTotalPrice(tour, guests, addOns);
});
```

### ‚úÖ Good for Prop Passing:

```javascript
// Storyblok Content
<StoryblokComponent blok={story.content} />

// Configuration Props
<Component variant="primary" size="large" disabled={false} />

// Event Handlers
<Button onClick={handleClick} onHover={handleHover} />

// Parent-Child Communication
<Modal isOpen={isModalOpen} onClose={closeModal}>
  <ModalContent data={modalData} />
</Modal>
```

## Migration Patterns

### When to Refactor FROM Local State TO Jotai:

```javascript
// üö® Signs you need to move to Jotai:

// 1. Prop drilling through 3+ levels
<GrandParent>
  <Parent cartItems={cartItems} setCartItems={setCartItems}>
    <Child cartItems={cartItems} setCartItems={setCartItems}>
      <GrandChild cartItems={cartItems} setCartItems={setCartItems} />
    </Child>
  </Parent>
</GrandParent>

// 2. Multiple StoryblokComponents need the same state
// ProductList, CartIcon, and CheckoutSummary all need cart data

// 3. State needs to persist across route changes
// User selections should survive navigation
```

### When to Refactor FROM Jotai TO Local State:

```javascript
// üö® Signs you should move to local state:

// 1. Only one component uses the atom
const onlyUsedHereAtom = atom(false); // Move to useState

// 2. Very high-frequency updates causing performance issues
const keystrokeAtom = atom(""); // Consider local state + debounced sync

// 3. Temporary UI state that doesn't need persistence
const tooltipVisibleAtom = atom(false); // Move to useState
```

## Performance Considerations

### Jotai Advantages:
- ‚úÖ Automatic dependency tracking
- ‚úÖ Only re-renders components that use changed atoms
- ‚úÖ Great for derived state
- ‚úÖ Prevents unnecessary prop drilling
- ‚úÖ Helps keep rendering cheap

### Local State Advantages:
- ‚úÖ Faster updates (no atom subscription overhead)
- ‚úÖ Easier to reason about in isolation
- ‚úÖ Better for high-frequency updates
- ‚úÖ Simpler debugging
- ‚úÖ No global state pollution

## General Philosophy

### The Progressive Enhancement Approach:

1. **Start with local state** for simple UI interactions
2. **Lift state up** when 2-3 components need to share
3. **Move to Jotai** when you hit prop drilling pain or need persistence

### Golden Rules:

- **Don't over-engineer early** - start simple, refactor when you feel pain
- **Prefer explicit over implicit** - make data flow obvious
- **Optimize for maintainability** - choose approaches that are easy to understand
- **One source of truth** - each piece of state should have one owner

### Red Flags:

- ‚ùå Fetching Storyblok content in every component
- ‚ùå Passing the same props through 3+ component levels
- ‚ùå Multiple components maintaining copies of the same state
- ‚ùå Complex useEffect chains trying to sync state
- ‚ùå Global atoms for purely local UI interactions

## Quick Reference Checklist

Before choosing your state management approach, ask:

- [ ] How many components need this state?
- [ ] Does this state need to persist across unmounts?
- [ ] Is this derived from other state?
- [ ] How frequently does this change?
- [ ] Is this UI interaction or business logic?
- [ ] Will this cause prop drilling?

### When in doubt, follow this simple rule:

**UI interactions ‚Üí Use local state** (useState for dropdowns, forms, tooltips)

**Data needed by multiple components ‚Üí Use Jotai atoms** (cart, user preferences, filters, tour data)

## Conclusion

State management in Storyblok React applications doesn't have to be complicated. By understanding the different categories of state and following the decision framework outlined in this guide, you can make informed choices that will scale with your application.

Remember, the best state management solution is the one that fits your specific use case. Start simple with local state, and progressively enhance with Jotai when you need the additional power and flexibility.

The key is to remain pragmatic: choose the right tool for the job, and don't be afraid to refactor as your application grows and requirements change.

## References

- [Jotai Documentation](https://jotai.org/)
- [Storyblok React SDK](https://github.com/storyblok/react)
- [Next.js State Management Patterns](https://nextjs.org/docs/app/building-your-application/data-fetching/patterns)