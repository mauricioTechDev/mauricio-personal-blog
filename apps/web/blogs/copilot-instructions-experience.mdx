import { BLOG_TAGS } from '@/lib/blog-tags'

export const metadata = {
  title: "Programming Copilot: My Journey with copilot-instructions.md",
  description: "How I used copilot-instructions.md to guide GitHub Copilot toward our team's best practices, and why this small file could have a big impact on developer experience.",
  date: '2025-06-19T12:00:00Z',
  tags: [BLOG_TAGS.COPILOT, BLOG_TAGS.AI_TOOLS, BLOG_TAGS.BEST_PRACTICES, BLOG_TAGS.DEVELOPER_EXPERIENCE, BLOG_TAGS.LLM],
}

For some time now, I've been using Copilot at my job and have really enjoyed the experience. But one thing I noticed when working with it on a certain codebaseâ€”a Next.js React applicationâ€”was that Copilot would often suggest patterns, styles, or packages that we typically *don't* use in our codebase. I found myself repeatedly going back to refactor Copilot's suggestions to fit our team's best practices. It was a bit like having a helpful but slightly forgetful coding buddy who just couldn't remember our house rules.

## The Problem: Copilot Doesn't Read Minds (Yet)

There are a few ways you could try to solve this. You could imagine a world where every company has a fine-tuned LLM, perfectly trained on their codebase and conventions. But for most teams (including mine), that's overkill. Every repo has its own quirks and nuances, and a one-size-fits-all model just isn't practical.

So, what if there was a lighter-weight way to nudge Copilot in the right direction?

## Discovering copilot-instructions.md

That's when I stumbled upon `copilot-instructions.md`. My first reaction was honestly a little skepticalâ€”was I really going to write a markdown file with instructions for an LLM? It felt almost silly, like leaving a note for a robot roommate. But the more I thought about it, the more it made sense. Programming is, at its core, about communicating intent. The *silly* thing would be to expect Copilot to magically know what I want without telling it.

So I gave it a shot. I wrote out some clear, specific instructions about our preferred patterns, packages, and style. And you know what? I noticed a difference *right away*. Copilot started suggesting code that was much closer to what I actually wanted. It wasn't perfect, but it was a big step forward.

## Why This Matters (and Why I'm Hopeful)

This is just the beginning. The beauty of `copilot-instructions.md` is that it's easy to iterate on. As our codebase evolves, or as we discover new best practices, we can update the instructions and see the impact almost immediately. It's a lightweight, flexible way to "program the programmer"â€”to shape the behavior of our AI tools without heavyweight infrastructure or process changes.

I'm genuinely excited about where this could go. We're entering an era where developers can not only write code, but also *write the rules* for how their AI assistants should behave. It's a new kind of programmingâ€”one that's less about syntax and more about intent, communication, and collaboration.

## Looking Forward

If you're using Copilot (or any AI coding tool) and finding yourself constantly tweaking its suggestions, give `copilot-instructions.md` a try. It might feel a little odd at first, but you might be surprised at how much of a difference it makes. And who knows? Maybe one day, programming will be as much about teaching our tools as it is about writing the tools themselves.

Here's to building better, togetherâ€”with a little help from our robot friends. ðŸš€ 